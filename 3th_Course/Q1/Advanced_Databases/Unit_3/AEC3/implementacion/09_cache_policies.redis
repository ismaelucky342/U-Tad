# ====================================================================================================#
#                                                                                                     #
#                                                         ██╗   ██╗   ████████╗ █████╗ ██████╗        #
#       AEC3 - ABDS                                       ██║   ██║   ╚══██╔══╝██╔══██╗██╔══██╗       #
#                                                         ██║   ██║█████╗██║   ███████║██║  ██║       #
#       created:        16/11/2025  -  03:00:11           ██║   ██║╚════╝██║   ██╔══██║██║  ██║       #
#       last change:    20/11/2025  -  22:55:40           ╚██████╔╝      ██║   ██║  ██║██████╔╝       #
#                                                          ╚═════╝       ╚═╝   ╚═╝  ╚═╝╚═════╝        #
#                                                                                                     #
#       Ismael Hernandez Clemente                         ismael.hernandez@live.u-tad.com             #
#                                                                                                     #
#       Github:                                           https://github.com/ismaelucky342            #
#                                                                                                     #
# ====================================================================================================#

# ========================================
# 1. CONFIGURACIÓN DE MEMORIA
# ========================================

# Ver configuración actual de memoria
CONFIG GET maxmemory
CONFIG GET maxmemory-policy

# Establecer límite de memoria (2GB)
CONFIG SET maxmemory 2gb

# Establecer política de desalojo cuando se llena la memoria
CONFIG SET maxmemory-policy allkeys-lru


# ========================================
# 2. POLÍTICAS DE DESALOJO DISPONIBLES
# ========================================

# noeviction: No desalojar, devolver error cuando está lleno
CONFIG SET maxmemory-policy noeviction

# allkeys-lru: Desalojar las claves menos usadas recientemente (LRU)
CONFIG SET maxmemory-policy allkeys-lru  # Mi elección para FleetHub

# allkeys-lfu: Desalojar las claves menos frecuentemente usadas
CONFIG SET maxmemory-policy allkeys-lfu

# allkeys-random: Desalojar claves aleatorias
CONFIG SET maxmemory-policy allkeys-random

# volatile-lru: Desalojar claves con TTL, las menos usadas
CONFIG SET maxmemory-policy volatile-lru

# volatile-lfu: Desalojar claves con TTL, las menos frecuentes
CONFIG SET maxmemory-policy volatile-lfu

# volatile-ttl: Desalojar claves con TTL más corto primero
CONFIG SET maxmemory-policy volatile-ttl

# volatile-random: Desalojar claves con TTL aleatoriamente
CONFIG SET maxmemory-policy volatile-random


# ========================================
# 3. ESTRATEGIA DE TTL PARA FLEETHUB
# ========================================

# Sesiones de usuario: 30 minutos
SETEX session:user:abc123 1800 '{"user_id":"C123","tipo":"cliente"}'

# Sesiones de conductor: 8 horas (turno completo)
SETEX session:driver:xyz789 28800 '{"user_id":"D456","vehiculo":"V001"}'

# Sesiones de admin: 1 hora (seguridad)
SETEX session:admin:mno345 3600 '{"user_id":"A789","tipo":"admin"}'

# Caché de vehículos: 5 minutos
SET cache:vehiculo:V001 '{"marca":"Mercedes","modelo":"Sprinter"}' EX 300

# Pre-reservas (carrito): 15 minutos
SETEX prereserva:PR001 900 '{"vehiculo":"V001","cliente":"C123"}'

# Reservas activas: duración del alquiler
# 3 días = 259200 segundos
HSET reserva:R001 vehiculo_id V001 cliente_id C123
EXPIRE reserva:R001 259200

# Tokens de recuperación: 1 hora
SETEX reset:token:abc789 3600 '{"email":"juan@email.com"}'

# Bloqueos temporales: según contexto
SET bloqueo:vehiculo:V001 R001 EX 259200  # Mientras dura la reserva

# Intentos de login: 15 minutos
SET login:attempts:juan@email.com 0 EX 900

# Métricas diarias: 7 días
SET stats:reservas:dia:2025-11-20 15 EX 604800

# Caché de búsquedas: 10 minutos
SET cache:busqueda:madrid:furgonetas '["V001","V004","V007"]' EX 600


# ========================================
# 4. VERIFICAR Y GESTIONAR TTL
# ========================================

# Ver tiempo restante de una clave (en segundos)
TTL session:user:abc123  # Devuelve segundos restantes

# TTL en milisegundos
PTTL session:user:abc123

# Casos especiales:
# TTL = -1  → La clave existe pero NO tiene expiración
# TTL = -2  → La clave NO existe

# Renovar expiración (extender sesión)
EXPIRE session:user:abc123 1800  # Reset a 30 minutos más

# Hacer que una clave NO expire
PERSIST session:user:abc123  # Ahora TTL = -1

# Verificar si una clave tiene expiración
TTL vehiculo:V001  # Si devuelve -1, no tiene TTL


# ========================================
# 5. EXPIRACIÓN CON SETEX Y PSETEX
# ========================================

# SET con expiración en UN comando (más eficiente)
SETEX cache:key 300 "valor"  # Equivale a: SET + EXPIRE

# SET con expiración en milisegundos
PSETEX cache:key 300000 "valor"  # 300 segundos = 300000 ms

# SET con opciones (Redis 6.2+)
SET cache:key "valor" EX 300  # Expiración en segundos
SET cache:key "valor" PX 300000  # Expiración en milisegundos
SET cache:key "valor" EXAT 1732147200  # Expira en timestamp Unix
SET cache:key "valor" PXAT 1732147200000  # Timestamp en ms


# ========================================
# 6. PATRÓN DE CACHÉ: CACHE-ASIDE
# ========================================

# 1. Intentar obtener del caché
GET cache:vehiculo:V001

# Si existe (hit) → usar ese valor
# Si no existe (miss) → consultar BD y cachear

# 2. Consultar BD (simulado)
# vehiculo = BD.query("SELECT * FROM vehiculos WHERE id = V001")

# 3. Guardar en caché
SET cache:vehiculo:V001 '{"marca":"Mercedes","modelo":"Sprinter"}' EX 300


# ========================================
# 7. INVALIDACIÓN DE CACHÉ
# ========================================

# Cuando actualizo un vehículo, invalido su caché
HSET vehiculo:V001 precio_dia 95.00
DEL cache:vehiculo:V001  # Forzar recaché en próxima consulta

# Invalidar caché de búsquedas relacionadas
DEL cache:busqueda:madrid:furgonetas
DEL cache:busqueda:madrid:todos


# ========================================
# 8. CACHÉ CON ACTUALIZACIÓN PROACTIVA
# ========================================

# En lugar de invalidar, actualizo el caché inmediatamente
HSET vehiculo:V001 precio_dia 95.00
SET cache:vehiculo:V001 '{"marca":"Mercedes","modelo":"Sprinter","precio_dia":95.00}' EX 300


# ========================================
# 9. EXPIRACIÓN POR LOTES
# ========================================

# Expirar múltiples claves relacionadas a la vez
MULTI
EXPIRE session:user:abc123 0  # Expira inmediatamente
EXPIRE session:user:def456 0
EXPIRE session:user:ghi789 0
EXEC

# O simplemente eliminarlas
DEL session:user:abc123 session:user:def456 session:user:ghi789


# ========================================
# 10. MONITOREO DE MEMORIA
# ========================================

# Ver uso actual de memoria
INFO memory

# Resultados relevantes:
# used_memory: Memoria usada por Redis en bytes
# used_memory_human: En formato legible (ej: 1.5G)
# used_memory_peak: Pico de memoria usado
# maxmemory: Límite configurado
# mem_fragmentation_ratio: Fragmentación

# Ver estadísticas de desalojos
INFO stats
# evicted_keys: Número de claves desalojadas


# ========================================
# 11. KEYS VOLÁTILES VS PERSISTENTES
# ========================================

# Claves SIN TTL (persistentes):
SET config:precios:base 50
SET config:iva 0.21
HSET stats:totales vehiculos 50 reservas 1547

# Claves CON TTL (volátiles):
SETEX session:user:abc123 1800 "..."
SET cache:vehiculo:V001 "..." EX 300

# Con política volatile-lru, solo desaloja las volátiles
# Con política allkeys-lru, desaloja cualquiera (mi elección)


# ========================================
# 12. EXPIRACIÓN PEREZOSA Y ACTIVA
# ========================================

# Redis elimina claves expiradas de 2 formas:

# 1. PEREZOSA (Lazy): Al acceder a una clave expirada
GET session:user:expired123  # (nil) - detecta que expiró y la elimina

# 2. ACTIVA (Active): Cada 100ms revisa claves aleatorias con TTL
# (Esto es automático, no requiere configuración)


# ========================================
# 13. CALLBACK DE EXPIRACIÓN (Keyspace Notifications)
# ========================================

# Habilitar notificaciones de eventos de expiración
CONFIG SET notify-keyspace-events Ex

# En otra conexión, suscribirse a eventos de expiración
# PSUBSCRIBE __keyevent@0__:expired

# Cuando una clave expira, recibes notificación:
# "session:user:abc123" expiró

# Útil para:
# - Limpiar índices relacionados
# - Enviar notificaciones
# - Logging


# ========================================
# 14. ESTRATEGIA DE CACHÉ PARA DIFERENTES DATOS
# ========================================

# Datos estáticos (raramente cambian): TTL largo
SET cache:config:ciudades '["Madrid","Barcelona","Valencia"]' EX 86400  # 24 horas

# Datos dinámicos (cambian frecuentemente): TTL corto
SET cache:vehiculos:disponibles:madrid '["V001","V004","V007"]' EX 60  # 1 minuto

# Datos en tiempo real: Sin caché o TTL muy corto
SET cache:ubicacion:V001 '{"lat":40.4168,"lon":-3.7038}' EX 10  # 10 segundos

# Datos críticos: No expiran (persistentes)
HSET vehiculo:V001 matricula "1234ABC" marca "Mercedes" modelo "Sprinter"
# Sin EXPIRE


# ========================================
# 15. CACHÉ DE CONSULTAS COMPLEJAS
# ========================================

# Resultado de una búsqueda compleja
SET cache:busqueda:madrid:furgonetas:disponibles:rango_50_100 '["V001","V004","V007"]' EX 300

# Ver si existe
EXISTS cache:busqueda:madrid:furgonetas:disponibles:rango_50_100

# Si existe → hit, devolver
# Si no existe → ejecutar búsqueda, cachear resultado


# ========================================
# 16. CACHÉ CON VERSIONES
# ========================================

# Incluir versión en la clave del caché
SET cache:v2:vehiculo:V001 '{"marca":"Mercedes"}' EX 300

# Al cambiar estructura de datos, incremento versión
SET cache:v3:vehiculo:V001 '{"marca":"Mercedes","año":2022}' EX 300

# Caché v2 expira naturalmente, sin necesidad de limpieza manual


# ========================================
# 17. WARMING UP DE CACHÉ
# ========================================

# Al inicio del sistema, pre-cachear datos importantes
SET cache:vehiculo:V001 '{"marca":"Mercedes","modelo":"Sprinter"}' EX 3600
SET cache:vehiculo:V002 '{"marca":"Iveco","modelo":"Daily"}' EX 3600
SET cache:vehiculo:V003 '{"marca":"Ford","modelo":"Transit"}' EX 3600
# ...para los vehículos más populares


# ========================================
# 18. GESTIÓN DE MEMORIA PROACTIVA
# ========================================

# Ver claves candidatas a desalojo (si política es allkeys-lru)
# SCAN 0 MATCH cache:* COUNT 100

# Eliminar cachés antiguos manualmente
DEL cache:vehiculo:V001 cache:vehiculo:V002 cache:vehiculo:V003

# Limpiar cachés de búsquedas
EVAL "return redis.call('del', unpack(redis.call('keys', ARGV[1])))" 0 cache:busqueda:*


# ========================================
# 19. ANÁLISIS DE HITS/MISSES
# ========================================

# Contadores de aciertos y fallos de caché
SET stats:cache:hits 0
SET stats:cache:misses 0

# Cada vez que consulto:
GET cache:vehiculo:V001

# Si devuelve valor:
INCR stats:cache:hits

# Si devuelve nil:
INCR stats:cache:misses

# Calcular tasa de aciertos
GET stats:cache:hits    # 8500
GET stats:cache:misses  # 1500
# Hit rate = 8500 / (8500 + 1500) = 85%


# ========================================
# 20. POLÍTICAS PERSONALIZADAS POR TIPO DE DATO
# ========================================

# No puedo tener diferentes políticas por clave en Redis,
# pero puedo simular con TTL estratégicos:

# Datos críticos: SIN TTL
HSET vehiculo:V001 matricula "1234ABC"

# Datos importantes: TTL largo
SET cache:config:precios "..." EX 3600

# Datos frecuentes: TTL medio
SET cache:vehiculo:V001 "..." EX 300

# Datos temporales: TTL corto
SET cache:busqueda:temporal "..." EX 60

# Redis desalojará primero los de TTL corto (con volatile-ttl)
# O los menos usados (con allkeys-lru)


# ========================================
# 21. RESUMEN DE MI ESTRATEGIA EN FLEETHUB
# ========================================

# Política global: allkeys-lru
CONFIG SET maxmemory-policy allkeys-lru
CONFIG SET maxmemory 2gb

# TTLs por tipo:
# - Sesiones usuario: 1800s (30min)
# - Sesiones conductor: 28800s (8h)
# - Sesiones admin: 3600s (1h)
# - Caché vehículos: 300s (5min)
# - Pre-reservas: 900s (15min)
# - Reservas: Duración del alquiler
# - Tokens reset: 3600s (1h)
# - Métricas diarias: 604800s (7d)
# - Búsquedas: 600s (10min)

# Notificaciones de expiración: Habilitadas
CONFIG SET notify-keyspace-events Ex

# Monitoreo:
INFO memory     # Uso de memoria
INFO stats      # Desalojos


# ========================================
# RESUMEN DE COMANDOS:
# ========================================
# EXPIRE <key> <seconds>         - Establecer expiración
# PEXPIRE <key> <milliseconds>   - Expiración en ms
# EXPIREAT <key> <timestamp>     - Expirar en timestamp Unix
# PEXPIREAT <key> <timestamp>    - Timestamp en ms
# TTL <key>                      - Ver tiempo restante (segundos)
# PTTL <key>                     - Ver tiempo restante (ms)
# PERSIST <key>                  - Eliminar expiración
# SETEX <key> <seconds> <value>  - SET con expiración
# PSETEX <key> <ms> <value>      - SET con expiración en ms
# CONFIG SET maxmemory <bytes>   - Límite de memoria
# CONFIG SET maxmemory-policy <policy> - Política de desalojo
# CONFIG GET maxmemory[-policy]  - Ver configuración
# INFO memory                    - Estadísticas de memoria
# CONFIG SET notify-keyspace-events - Habilitar notificaciones
# ========================================


# ========================================
# NOTAS PERSONALES:
# ========================================
# - allkeys-lru es mi política favorita: desaloja lo menos usado automáticamente
# - TTL estratégicos por tipo de dato optimizan el uso de memoria
# - SETEX es más eficiente que SET + EXPIRE (un solo comando)
# - TTL de sesiones cortos = mejor seguridad
# - Caché con TTL corto para datos dinámicos, largo para estáticos
# - Keyspace notifications me permiten reaccionar a expiraciones
# - volatile-ttl + TTLs bien diseñados = desalojo inteligente
# - PERSIST es útil cuando una sesión temporal se vuelve permanente
# - Monitorear evicted_keys para saber si necesito más memoria
# - Pre-cachear (warm-up) datos importantes al iniciar el sistema
# 
# PARA FLEETHUB:
# ✅ Sesiones con auto-expiración = seguridad + limpieza automática
# ✅ Reservas con TTL = no necesito cronjobs de limpieza
# ✅ Caché de vehículos = respuestas ultra-rápidas
# ✅ Pre-reservas expiradas = carrito abandonado auto-limpiado
# ✅ Bloqueos temporales = evita race conditions sin cleanup manual
# ✅ allkeys-lru = memoria siempre optimizada sin intervención
# ========================================
